#!/bin/bash
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2010             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# Check_MK agent plugin for monitoring ORACLE databases

# last change 06.04.2014

MK_SQLTMPDIR="/tmp"
# Get list of all running databases
# Do not work on ASM in this plugin. => Ignore a running ASM-Instance!
SIDS=$(UNIX95=true ps ax -o args | grep -v " ora_pmon_+ASM" | sed -n '/^\(ora\|xe\)_pmon_\([^ ]*\)/s//\2/p')
if [ -z "$SIDS" ] ; then 
    # If on this system we've already found a database
    if [ -e "$MK_CONFDIR/mk_oracle.found" ] ; then
        echo '<<<oracle_version>>>'
        echo '<<<oracle_sessions>>>'
        echo '<<<oracle_logswitches>>>'
        echo '<<<oracle_tablespaces>>>'
        echo '<<<oracle_ts_quotas>>>'
        echo '<<<oracle_resumable>>>'
        echo '<<<oracle_instance>>>'
        echo '<<<oracle_undostat>>>'
        echo '<<<oracle_recovery_area>>>'
        echo '<<<oracle_processes>>>'
        echo '<<<oracle_jobs>>>'
        echo '<<<oracle_perfdata>>>'
    fi
    exit 0
fi

touch $MK_CONFDIR/mk_oracle.found

# Recreate data if cachefile is older than 120 seconds.
# If you set this to 0, then the cache file will be created
# as often as possible. If the database queries last longer
# then your check interval, caching will be active nevertheless.
CACHE_MAXAGE=120
CACHE_MAXAGE_TABLESPACE=600

# Source the optional configuration file for this agent plugin
if [ -e "$MK_CONFDIR/mk_oracle.cfg" ]
then
    . $MK_CONFDIR/mk_oracle.cfg
fi

# You can specify a list of SIDs to monitor. Those databases will
# only be handled, if they are found running, though! 
#
#   ONLY_SIDS="XE HIRN SEPP"
#
# It is possible to filter SIDS negatively. Just add the following to
# the mk_oracle.cfg file:
#
#   EXCLUDE_<sid>="ALL"
#
# Another option is to filter single checks for SIDS. Just add
# lines as follows to the mk_oracle.cfg file. One service per
# line:
#
#   EXCLUDE_<sid>="<service>"
#
# For example skip oracle_sessions and oracle_logswitches checks
# for the instance "mysid".
#
#   EXCLUDE_mysid="sessions logswitches"
#
#
# This check uses a cache file to prevent problems with long running
# SQL queries. It starts building a cache when
#   a) no cache is present or the cache is too old and
#   b) the cache is not currently being built
# The cache is used for $CACHE_MAXAGE seconds. The CACHE_MAXAGE
# option is pre-set to 120 seconds but can be changed in mk_oracle.cfg.

# complete rework of the plugin done by Thorsten Bruhns (thorsten.bruhns@opitz-consulting.com)
# There is a new strategy in this plugin. We loop over all SIDs with EXLUDE an INCLUDEs like before.
# We don't do a login for each check anymore. The needed checks are written 
# to a sql-file and executed together in 1 Session. This reduces the number
# of logins to the database and increases the speed of the plugin.
#
# There is an ability to configre a cache time for each type of check.
# Tablespace-Checks every 10 minutes due to high load on databases with a lot of tablespaces!
# Sessions are checked at 2 minutes interval
#
#
# Remove old cache files at the start of the plugin. No old garbage from non existing 
# databases anymore.
# Create a temporary sql file in /tmp for each execute of the plugin. This file includes 
# only the needed checks dependent from the age of the cache files. This gives us the ability 
# to use different ages for the type of checks.
#
# Local functions
# - clear cache
#   remove old cache files from database who are not running anymore
# - sqlplus
#   start SQLPlus
#

#
function sqlplus ()
{
    if OUTPUT=$({ echo 'set pages 0 trimspool on feedback off lines 8000' ; echo 'whenever sqlerror exit 1'; cat ; } | $MK_CONFDIR/sqlplus.sh $1)
    then
        # add ORACLE_SID at start of each line. Don't do that for line with '<<<text>>>'
        export OUTPUT
        return 0
    else
        OUTPUT=${OUTPUT} | sed "s/^/$1 FAILURE /"
        export OUTPUT
        return 1
    fi
}

clear_cache ()
{
    # remove old cache-files
    # cached files are removed after 120 minutes
    CLEAN_CACHE_MAXAGE=7200
    if [ -d $MK_CONFDIR ]
    then
        NOW=$(date +%s)
        for CACHE_FILE in $(find $MK_CONFDIR -name "oracle_*.cache")
        do
            MTIME=$(stat -c %Y $CACHE_FILE)
            if [ $(($NOW - $MTIME)) -ge $CLEAN_CACHE_MAXAGE ]
            then
                rm -f $CACHE_FILE
            fi
        done
    fi
    # remove old temporary data from tmp
    # we need to spool to /tmp from sqlplus and move the result to MK_CONFDIR
    for CACHE_FILE in $(find $TMP_CACHEDIR -name ".check_mk_oracle_*.cache")
    do
        MTIME=$(stat -c %Y $CACHE_FILE)
        if [ $(($NOW - $MTIME)) -ge $CLEAN_CACHE_MAXAGE ]
        then
            rm -f $CACHE_FILE
        fi
    done
}

do_spool_tablespace()
{
    # convert READ ONLY to READONLY for later splitting of results in cmk.
    filename=${1}
    resultfile=$2
    echo "spool "$resultfile >> $filename
    echo 'PROMPT <<<oracle_tablespaces>>>' >> $filename
    echo "select d.NAME || ' ' || file_name ||' '|| tablespace_name ||' '|| fstatus ||' '|| AUTOEXTENSIBLE
              ||' '|| blocks ||' '|| maxblocks ||' '|| USER_BLOCKS ||' '|| INCREMENT_BY 
              ||' '|| ONLINE_STATUS ||' '|| BLOCK_SIZE 
              ||' '|| decode(tstatus,'READ ONLY', 'READONLY', tstatus) || ' ' || free_blocks 
              ||' '|| contents
       from v\$database d , (
                select f.file_name, f.tablespace_name, f.status fstatus, f.AUTOEXTENSIBLE,
                f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY,
                f.ONLINE_STATUS, t.BLOCK_SIZE, t.status tstatus, nvl(sum(fs.blocks),0) free_blocks, t.contents
                from dba_data_files f, dba_tablespaces t, dba_free_space fs
                where f.tablespace_name = t.tablespace_name
                and f.file_id = fs.file_id(+)
                group by f.file_name, f.tablespace_name, f.status, f.autoextensible,
                f.blocks, f.maxblocks, f.user_blocks, f.increment_by, f.online_status,
                t.block_size, t.status, t.contents
                UNION
                select f.file_name, f.tablespace_name, f.status, f.AUTOEXTENSIBLE,
                f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY, 'TEMP',
                t.BLOCK_SIZE, t.status, sum(sh.blocks_free) free_blocks, 'TEMPORARY'
                from v\$thread th, dba_temp_files f, dba_tablespaces t, v\$temp_space_header sh
                WHERE f.tablespace_name = t.tablespace_name and f.file_id = sh.file_id
                GROUP BY th.instance, f.file_name, f.tablespace_name, f.status,
                f.autoextensible, f.blocks, f.maxblocks, f.user_blocks, f.increment_by,
                'TEMP', t.block_size, t.status);
" >> $filename
}

do_spool_rman_backup()
{
    filename=${1}
    resultfile=$2
    echo "spool "$resultfile >> $filename
    echo 'PROMPT <<<oracle_rman_backups>>>' >> $filename
    echo "SELECT d.NAME
                 ||' '|| b.COMMAND_ID
                 ||' '|| a.STATUS
                 ||' '|| to_char(a.START_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                 ||' '|| to_char(a.END_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                 ||' '|| b.INPUT_TYPE
                 FROM V\$RMAN_BACKUP_JOB_DETAILS a, v\$database d,
                      (SELECT input_type, max(command_id) as command_id
                       FROM V\$RMAN_BACKUP_JOB_DETAILS WHERE STATUS<>'RUNNING' GROUP BY input_type) b
                 WHERE a.COMMAND_ID = b.COMMAND_ID;
         " >> $filename
}

do_spool_perfdata()
{
    filename=${1}
    echo 'PROMPT <<<oracle_perfdata>>>' >> $filename
    echo "with metrics as
          (
           SELECT a.begin_time
                 ,a.metric_id
                 ,decode(a.metric_id, 2123, 'dbtime_cs'
                                    , 2107, 'dbwait_pct'
                                    , 2108, 'dbcpu_pct'
                        ) metricname
                 , value
           FROM V\$SYSMETRIC_HISTORY a
           join V\$METRICNAME b
             on a.metric_id = b.metric_id
            and a.group_id = b.group_id
          WHERE a.metric_id in (2107,2108,2123)
            and a.group_id = 2
          )
          select instance_name
                 ||' '|| metricname
                 ||' '|| val1
                 ||' '|| val5
                 ||' '|| val15
          from (
          select vi.instance_name
                ,dbt1.metricname
                ,round(avg(dbt1.value),0)  val1
                ,round(avg(dbt5.value),0)  val5
                ,round(avg(dbt15.value),0) val15
          from metrics dbt1, metrics dbt5, metrics dbt15, v\$instance vi
          where dbt1.metric_id   = dbt5.metric_id
            and dbt15.metric_id  = dbt5.metric_id
            and dbt1.begin_time  > sysdate - 2*(1/24/60)
            and dbt5.begin_time  > sysdate - 5*(1/24/60)
            and dbt15.begin_time > sysdate - 15*(1/24/60)
          group by vi.instance_name, dbt1.metricname
               );" >> $filename

}

do_spool_recovery_area()
{
    filename=${1}
    echo 'PROMPT <<<oracle_recovery_area>>>' >> $filename
    echo "select d.NAME
                 ||' '|| round((SPACE_USED-SPACE_RECLAIMABLE)/SPACE_LIMIT*100)
                 ||' '|| round(SPACE_LIMIT/1024/1024)
                 ||' '|| round(SPACE_USED/1024/1024)
                 ||' '|| round(SPACE_RECLAIMABLE/1024/1024)
          from V\$RECOVERY_FILE_DEST, v\$database d;
         " >> $filename
}

do_spool_undostat()
{
    filename=${1}
    echo 'PROMPT <<<oracle_undostat>>>' >> $filename
    echo "select i.INSTANCE_NAME
                 ||' '|| ACTIVEBLKS
                 ||' '|| MAXCONCURRENCY
                 ||' '|| TUNED_UNDORETENTION
                 ||' '|| maxquerylen
                 ||' '|| NOSPACEERRCNT
          from v\$instance i,
              (select * from (select * 
                              from v\$undostat order by end_time desc
                             )
                        where rownum = 1
                        and TUNED_UNDORETENTION > 0
              );
         " >> $filename
}

do_spool_resumable()
{
    filename=${1}
    echo 'PROMPT <<<oracle_resumable>>>' >> $filename
    echo "select i.INSTANCE_NAME
                 ||' '|| u.username
                 ||' '|| a.SESSION_ID
                 ||' '|| a.status
                 ||' '|| a.TIMEOUT
                 ||' '|| round((sysdate-to_date(a.SUSPEND_TIME,'mm/dd/yy hh24:mi:ss'))*24*60*60)
                 ||' '|| a.ERROR_NUMBER
                 ||' '|| to_char(to_date(a.SUSPEND_TIME, 'mm/dd/yy hh24:mi:ss'),'mm/dd/yy_hh24:mi:ss')
                 ||' '|| a.RESUME_TIME
                 ||' '|| a.ERROR_MSG
          from dba_resumable a, v\$instance i, dba_users u
          where a.INSTANCE_ID = i.INSTANCE_NUMBER
          and u.user_id = a.user_id
          and a.SUSPEND_TIME is not null
;
         " >> $filename
}

do_spool_scheduler_jobs()
{
    filename=${1}
    resultfile=$2
    echo "spool "$resultfile >> $filename
    echo 'PROMPT <<<oracle_jobs>>>' >> $filename
    echo "SELECT d.NAME
                 ||' '|| j.OWNER
                 ||' '|| j.JOB_NAME
                 ||' '|| j.STATE
                 ||' '|| (TRUNC(sysdate) + j.LAST_RUN_DURATION - TRUNC(sysdate)) * 86400
                 ||' '|| j.RUN_COUNT
                 ||' '|| j.ENABLED
                 ||' '|| NVL(j.NEXT_RUN_DATE, to_date('1970-01-01', 'YYYY-mm-dd'))
                 ||' '|| NVL(j.SCHEDULE_NAME, '-')
                 ||' '|| d.STATUS
          FROM dba_scheduler_jobs j, dba_scheduler_job_run_details d, v\$database d
          WHERE d.owner=j.OWNER AND d.JOB_NAME=j.JOB_NAME
            AND d.LOG_ID=(SELECT max(LOG_ID) FROM dba_scheduler_job_run_details dd
                          WHERE dd.owner=j.OWNER and dd.JOB_NAME=j.JOB_NAME
                         );
         " >> $filename
}


do_spool_ts_quotas()
{
    filename=${1}
    resultfile=$2
    echo "spool "$resultfile >> $filename
    echo 'PROMPT <<<oracle_ts_quotas>>>' >> $filename
    echo "select d.NAME
                 ||' '|| USERNAME 
                 ||' '|| TABLESPACE_NAME
                 ||' '|| round(bytes/max_bytes*100)
                 ||' '|| BYTES/1024/1024
                 ||' '|| MAX_BYTES/1024/1024
          from dba_ts_quotas, v\$database d
          where max_bytes  > 0
          order by 1;
         " >> $filename
}

create_result_for_check()
{
    loc_CHECK_NAME=$1
    loc_CACHE_MAXAGE=$2
    loc_MK_SQLRESULT=$3
    loc_MK_SQLTMPFILE=$4
    loc_DO_SPOOL_NAME=$5

    # current date in unixtime for later usage
    NOW=$(date +%s)
    if [ ! '$EXCLUDE' = '${EXCLUDE/todo/}' ]; then
        # do we have a cached file?
        if [ -f $loc_MK_SQLRESULT ]; then
            # Is the cached file outdated?
            MTIME=$(stat -c %Y $loc_MK_SQLRESULT)
            if [ $(($NOW - $MTIME)) -gt $loc_CACHE_MAXAGE ]; then
                # remove old file!
                rm -f $loc_MK_SQLRESULT
                # create sql for $CHECK_NAME
                $loc_DO_SPOOL_NAME $loc_MK_SQLTMPFILE $loc_MK_SQLRESULT
            else
                # print cached data
                cat $loc_MK_SQLRESULT
            fi
        else
            # create sql for tablespace monitoring
            $loc_DO_SPOOL_NAME $loc_MK_SQLTMPFILE $loc_MK_SQLRESULT
        fi
    fi
}

do_version_checks()
{
        # oracle_instance: uptime is 0 when sysdate > startup_time in instance
        #                  this is required when time is changed on the host
        # sqlplus returns OUTPUT with the result of the check!
        sqlplus $SID <<_EOF_
           PROMPT <<<oracle_version>>>
           select i.INSTANCE_NAME
                  || ' ' || banner 
                  from v\$version, v\$instance i
                  where banner like 'Oracle%';

           prompt <<<oracle_instance>>>
           select i.instance_name
	          || ' ' || i.VERSION
	          || ' ' || i.STATUS
	          || ' ' || i.LOGINS
	          || ' ' || i.ARCHIVER
                  || ' ' || to_char(i.startup_time,'dd.mm.yyyy_hh24:mi:ss') 
                  || ' ' || DBID
                  || ' ' || LOG_MODE
                  || ' ' || DATABASE_ROLE
                  || ' ' || FORCE_LOGGING
                  || ' ' || case when ((sysdate-startup_time)<0) then 0 
                                 else (sysdate-startup_time)*24*60*60 end
	          || ' ' || d.name
           from v\$instance i, v\$database d;

           prompt <<<oracle_sessions>>>
           select i.instance_name
                  || ' ' || CURRENT_UTILIZATION
           from v\$resource_limit, v\$instance i
           where RESOURCE_NAME = 'sessions';

           prompt <<<oracle_processes>>>
           select i.instance_name
                  || ' ' || CURRENT_UTILIZATION
                  || ' ' || ltrim(rtrim(LIMIT_VALUE))
           from v\$resource_limit, v\$instance i
           where RESOURCE_NAME = 'processes';

           prompt <<<oracle_logswitches>>>
           select i.instance_name
                  || ' ' || logswitches
           from v\$instance i ,
                (select count(1) logswitches
                 from v\$loghist 
                 where first_time > sysdate - 1/24
                );
_EOF_
if [ ${?} -ne 0 ]
then
    # We need to print the sections when sqlplus results an error
    # => otherwise the Check_MK generates an error due to missiing sections
    echo "<<<oracle_version>>>"
    echo "<<<oracle_instance>>>"
    # We print the whole result to oracle_instance for debugging
    echo "${OUTPUT}"  | sed "s/^/$SID FAILURE /" | grep "^"$SID" FAILURE ORA-"

    echo "<<<oracle_sessions>>>"
    echo "<<<oracle_processes>>>"
    echo "<<<oracle_logswitches>>>"
    echo "<<<oracle_undostat>>>"
else
    #
    echo -e "$OUTPUT"
fi
}

  # #          #     #     #     ###  #     #          # #
  # #          ##   ##    # #     #   ##    #          # #
#######        # # # #   #   #    #   # #   #        #######
  # #          #  #  #  #     #   #   #  #  #          # #
#######        #     #  #######   #   #   # #        #######
  # #          #     #  #     #   #   #    ##          # #
  # #          #     #  #     #  ###  #     #          # #

clear_cache

for SID in $SIDS; do
    # Check if SID is listed in ONLY_SIDS if this is used
    if [ "$ONLY_SIDS" ] ; then
        SKIP=yes
        for S in $ONLY_SIDS ; do
	    if  [ "$S" = "$SID" ] ; then
                SKIP=
                break
            fi 
        done
        if [ "$SKIP" ] ; then continue ; fi
    fi
        
    EXCLUDE=EXCLUDE_$SID
    EXCLUDE=${!EXCLUDE}
    # SID filtered totally?
    if [ "$EXCLUDE" = "ALL" ]; then
        continue
    fi

    # MK_SQLTMPFILE is execute in sqlplus.sh at the end of the loop
    # we need an unique identifier for the sql-file
    MK_SQLTMPDIR=/tmp
    MK_SQLTMPFILE=$MK_SQLTMPDIR"/.mk_oracle_oracle_"$SID"_"$(date +%s)".sql"
    MK_SQLTMPFILENOW=$MK_SQLTMPDIR"/.mk_oracle_oracle_"$SID"_now_"$(date +%s)".sql"

    # store the result of sqlplus.sh for each check in 1 file
    # we won't execute every check while running the agent
    # => we add the chached data for each check to complete the result of the agent

    MK_SQLRESULT_TABLESPACE=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_tablespace.data"
    MK_SQLRESULT_RMAN_BACKUP=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_rman_backup.data"
    MK_SQLRESULT_JOBS=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_jobs.data"
    MK_SQLRESULT_TS_QUOTA=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_ts_quota.data"

    # This dummy is needed for checks in 
    MK_SQLRESULT_DUMMY=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_dummy.data"

    # Do Version-Check (use as a general login check) without caching
    # get some interesting data from database and instance
    # these sqls are really fast. No need to cache these results!
    # These Checks are running from 9i onwards. No need for filtering atm
    if [ "$EXCLUDE" = "${EXCLUDE/version/}" ]; then
        do_version_checks
    fi

    ###########################################################
    #      synchronous Checks
    ###########################################################
    # no caching on recovery area
    # => this v$-view has a low performance impact on the database
    # => This is only availible from 10g onwards
    create_result_for_check recovery_area 1 $MK_SQLRESULT_DUMMY ${MK_SQLTMPFILENOW}"_dummy" do_spool_recovery_area

    # 'spool' in sqlplus overwrites the spoolfile everytime a new file with same name is opened
    # add sql-statement from create_result_for_check to MK_SQLTMPFILENOW
    cat ${MK_SQLTMPFILENOW}"_dummy" > ${MK_SQLTMPFILENOW}
    rm -f ${MK_SQLTMPFILENOW}"_dummy"

    # create performance data for DB Time, CPU Time and wait Time
    create_result_for_check perfdata 1 $MK_SQLRESULT_DUMMY ${MK_SQLTMPFILENOW}"_dummy" do_spool_perfdata
    cat ${MK_SQLTMPFILENOW}"_dummy" >> ${MK_SQLTMPFILENOW}
    rm -f ${MK_SQLTMPFILENOW}"_dummy"

# vorerst entfernt, weil es noch Probleme mit Instancen im MOUNT-Status gibt!
#    create_result_for_check resumable 1 $MK_SQLRESULT_DUMMY ${MK_SQLTMPFILENOW}"_dummy" do_spool_resumable
#    cat ${MK_SQLTMPFILENOW}"_dummy" >> ${MK_SQLTMPFILENOW}
#    rm -f ${MK_SQLTMPFILENOW}"_dummy"

    create_result_for_check undostat 1 $MK_SQLRESULT_DUMMY ${MK_SQLTMPFILENOW}"_dummy" do_spool_undostat
    cat ${MK_SQLTMPFILENOW}"_dummy" >> ${MK_SQLTMPFILENOW}
    rm -f ${MK_SQLTMPFILENOW}"_dummy"


    # only try to execute sqlplus when data must be read from database
    # this is the synchronous call!
    if [ -f $MK_SQLTMPFILENOW ]
    then
        sqlplus $SID <<_EOF_
@$MK_SQLTMPFILENOW
_EOF_

    if [ ${?} -ne 0 ]
    then
        # We need to print the sections when sqlplus results an error
        # => otherwise the Check_MK generates an error due to missiing sections
        echo "<<<oracle_undostat>>>"
    else
        #
        echo -e "$OUTPUT"
    fi




    fi

    ###########################################################
    #      asynchronous Checks
    ###########################################################
    create_result_for_check tablespaces $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_TABLESPACE $MK_SQLTMPFILE do_spool_tablespace
    create_result_for_check ts_quotas $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_TS_QUOTA $MK_SQLTMPFILE do_spool_ts_quotas
    create_result_for_check rman_backup $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_RMAN_BACKUP $MK_SQLTMPFILE do_spool_rman_backup
    create_result_for_check jobs $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_JOBS $MK_SQLTMPFILE do_spool_scheduler_jobs

    # only try to execute sqlplus when data must be read from database
    # this is the asynchronous call!
    if [ -f $MK_SQLTMPFILE ]
    then
        setsid bash -c "
            set -o noclobber
            function sqlplus ()
            {
                if OUTPUT=\$({ echo 'set pages 0 trimspool on' ; echo 'whenever OSERROR  EXIT ROLLBACK' ; echo 'whenever sqlerror exit 1'; echo 'set lines 8000' ; echo 'set feedback off'; cat ; } | $MK_CONFDIR/sqlplus.sh \$1)
               then
                   export OUTPUT
                   return 0
                   #echo \"\${OUTPUT}\"
               else
                   OUTPUT=\$\{OUTPUT\} | sed \"s/^/\$1 FAILURE /\"
                   export OUTPUT
                   return 1
                   #echo \"\$\{OUTPUT\}\" | sed \"s/^/\$1 FAILURE /\"
                fi
            }
        sqlplus "$SID" <<_EOF_
@$MK_SQLTMPFILE
_EOF_
        if [ \${?} -ne 0 ]
    then
        # We need to print the sections when sqlplus results an error
        # => otherwise the Check_MK generates an error due to missiing sections
        echo '<<<oracle_tablespaces>>>'
        echo '<<<oracle_ts_quotas>>>'
        echo '<<<oracle_resumable>>>'
        echo '<<<oracle_recovery_area>>>'
        echo '<<<oracle_jobs>>>'
    else
        #
        echo -e \"\$OUTPUT\"
    fi
        "
    fi

    rm -f $MK_SQLTMPFILE $MK_SQLTMPFILENOW

done

