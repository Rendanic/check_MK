#!/bin/bash
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2010             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# mk_oracle Version 0.7.3
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
#
# Check_MK agent plugin for monitoring ORACLE databases

MK_SQLTMPDIR="/tmp"
# Get list of all running databases
# Do not work on ASM in this plugin. => Ignore a running ASM-Instance!
SIDS=$(UNIX95=true ps -ef | grep -v " ora_pmon_+ASM" | awk '{print $NF}' | grep '^ora_pmon_' | cut -d"_" -f3)
if [ -z "$SIDS" ] ; then 
    # If on this system we've already found a database
    if [ -e "$MK_CONFDIR/mk_oracle.found" ] ; then
        echo '<<<oracle_version>>>'
        echo '<<<oracle_sessions>>>'
        echo '<<<oracle_logswitches>>>'
        echo '<<<oracle_tablespaces>>>'
        echo '<<<oracle_ts_quotas>>>'
        echo '<<<oracle_resumable>>>'
        echo '<<<oracle_rman_backups>>>'
        echo '<<<oracle_instance>>>'
        echo '<<<oracle_undostat>>>'
        echo '<<<oracle_recovery_area>>>'
        echo '<<<oracle_processes>>>'
        echo '<<<oracle_jobs>>>'
    fi
    exit 0
fi

touch $MK_CONFDIR/mk_oracle.found

# Recreate data if cachefile is older than 120 seconds.
# If you set this to 0, then the cache file will be created
# as often as possible. If the database queries last longer
# then your check interval, caching will be active nevertheless.
CACHE_MAXAGE=120
CACHE_MAXAGE_TABLESPACE=600
TMP_CACHEDIR=/var/tmp

# Source the optional configuration file for this agent plugin
if [ -e "$MK_CONFDIR/mk_oracle.cfg" ]
then
    . $MK_CONFDIR/mk_oracle.cfg
fi

# You can specify a list of SIDs to monitor. Those databases will
# only be handled, if they are found running, though! 
#
#   ONLY_SIDS="XE HIRN SEPP"
#
# It is possible to filter SIDS negatively. Just add the following to
# the mk_oracle.cfg file:
#
#   EXCLUDE_<sid>="ALL"
#
# Another option is to filter single checks for SIDS. Just add
# lines as follows to the mk_oracle.cfg file. One service per
# line:
#
#   EXCLUDE_<sid>="<service>"
#
# For example skip oracle_sessions and oracle_logswitches checks
# for the instance "mysid".
#
#   EXCLUDE_mysid="sessions logswitches"
#
#
# This check uses a cache file to prevent problems with long running
# SQL queries. It starts building a cache when
#   a) no cache is present or the cache is too old and
#   b) the cache is not currently being built
# The cache is used for $CACHE_MAXAGE seconds. The CACHE_MAXAGE
# option is pre-set to 120 seconds but can be changed in mk_oracle.cfg.

# complete rework of the plugin done by Thorsten Bruhns (thorsten.bruhns@opitz-consulting.com)
# There is a new strategy in this plugin. We loop over all SIDs with EXLUDE an INCLUDEs like before.
# We don't do a login for each check anymore. The needed checks are written 
# to a sql-file and executed together in 1 Session. This reduces the number
# of logins to the database and increases the speed of the plugin.
#
# There is an ability to configre a cache time for each type of check.
# Tablespace-Checks every 10 minutes due to high load on databases with a lot of tablespaces!
# Sessions are checked at 2 minutes interval
#
#
# Remove old cache files at the start of the plugin. No old garbage from non existing 
# databases anymore.
# Create a temporary sql file in /tmp for each execute of the plugin. This file includes 
# only the needed checks dependent from the age of the cache files. This gives us the ability 
# to use different ages for the type of checks.
#
# Removed 'stat' for checking the cache state.
# => AIX and HP/UX doesn't have stat per default.
# => creating a '.timestamp'-File with unixtime as content

# Local functions
# - clear cache
#   remove old cache files from database who are not running anymore
# - sqlplus
#   start SQLPlus
#

#
function sqlplus ()
{
    if OUTPUT=$({ echo 'set pages 0 trimspool on feedback off lines 8000' ; echo 'whenever sqlerror exit 1'; cat ; } | $MK_CONFDIR/sqlplus.sh $1)
    then
        # add ORACLE_SID at start of each line. Don't do that for line with '<<<text>>>'
        export OUTPUT
        return 0
    else
        OUTPUT=${OUTPUT} | sed "s/^/$2 FAILURE /"
        export OUTPUT
        return 1
    fi
}

clear_cache ()
{
    # remove old cache-files
    # cached files are removed after 120 minutes
    CLEAN_CACHE_MAXAGE=7200
    if [ -d $MK_CONFDIR ]
    then
        NOW=$(date +%s)
        for CACHE_FILE in $(find $MK_CONFDIR -name "oracle_*.cache.timestamp")
        do
            MTIME=$(cat $CACHE_FILE)
            if [ $(($NOW - $MTIME)) -ge $CLEAN_CACHE_MAXAGE ]
            then
                rm -f $CACHE_FILE
            fi
        done
    fi
    # remove old temporary data from tmp
    # we need to spool to /tmp from sqlplus and move the result to MK_CONFDIR
    for CACHE_FILE in $(find $TMP_CACHEDIR -name ".check_mk_oracle_*.cache*")
    do
        MTIME=$(stat -c %Y $CACHE_FILE)
        if [ $(($NOW - $MTIME)) -ge $CLEAN_CACHE_MAXAGE ]
        then
            rm -f $CACHE_FILE
        fi
    done
}

do_spool_tablespace()
{
    # convert READ ONLY to READONLY for later splitting of results in cmk.
    filename=${1}
    resultfile=$2
    resultfiletmp=${resultfile}.tmp
    echo "spool "$resultfiletmp >> $filename
    echo 'PROMPT <<<oracle_tablespaces>>>' >> $filename
    echo "select upper(d.NAME) || ' ' || file_name ||' '|| tablespace_name ||' '|| fstatus ||' '|| AUTOEXTENSIBLE
              ||' '|| blocks ||' '|| maxblocks ||' '|| USER_BLOCKS ||' '|| INCREMENT_BY 
              ||' '|| ONLINE_STATUS ||' '|| BLOCK_SIZE 
              ||' '|| decode(tstatus,'READ ONLY', 'READONLY', tstatus) || ' ' || free_blocks 
              ||' '|| contents
       from v\$database d , (
                select f.file_name, f.tablespace_name, f.status fstatus, f.AUTOEXTENSIBLE,
                f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY,
                f.ONLINE_STATUS, t.BLOCK_SIZE, t.status tstatus, nvl(sum(fs.blocks),0) free_blocks, t.contents
                from dba_data_files f, dba_tablespaces t, dba_free_space fs
                where f.tablespace_name = t.tablespace_name
                and f.file_id = fs.file_id(+)
                group by f.file_name, f.tablespace_name, f.status, f.autoextensible,
                f.blocks, f.maxblocks, f.user_blocks, f.increment_by, f.online_status,
                t.block_size, t.status, t.contents
                UNION
                select f.file_name, f.tablespace_name, f.status, f.AUTOEXTENSIBLE,
                f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY, 'TEMP',
                t.BLOCK_SIZE, t.status, sum(sh.blocks_free) free_blocks, 'TEMPORARY'
                from v\$thread th, dba_temp_files f, dba_tablespaces t, v\$temp_space_header sh
                WHERE f.tablespace_name = t.tablespace_name and f.file_id = sh.file_id
                GROUP BY th.instance, f.file_name, f.tablespace_name, f.status,
                f.autoextensible, f.blocks, f.maxblocks, f.user_blocks, f.increment_by,
                'TEMP', t.block_size, t.status);
          " >> $filename
    echo "!mv -f "$resultfiletmp" "$resultfile" ; date +%s > "${resultfile}.timestamp >> $filename
}

do_spool_rman_backup()
{
    filename=${1}
    resultfile=$2
    resultfiletmp=${resultfile}.tmp
    echo "spool "$resultfiletmp >> $filename
    echo 'PROMPT <<<oracle_rman_backups>>>' >> $filename
    echo "SELECT upper(d.NAME)
                 ||' '|| a.STATUS
                 ||' '|| to_char(a.START_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                 ||' '|| to_char(a.END_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                 ||' '|| replace(b.INPUT_TYPE, ' ', '_') 
                 ||' '|| round(((sysdate - END_TIME) * 24 * 60),0)
                 FROM V\$RMAN_BACKUP_JOB_DETAILS a, v\$database d,
                      (SELECT input_type, max(command_id) as command_id
                       FROM V\$RMAN_BACKUP_JOB_DETAILS 
                      WHERE START_TIME > sysdate-14 
                        and STATUS<>'RUNNING' GROUP BY input_type) b
                 WHERE a.COMMAND_ID = b.COMMAND_ID;
         " >> $filename
    echo "!mv -f "$resultfiletmp" "$resultfile" ; date +%s > "${resultfile}.timestamp >> $filename
}

do_spool_recovery_area()
{
    filename=${1}
    echo 'PROMPT <<<oracle_recovery_area>>>' >> $filename
    echo "select upper(d.NAME)
                 ||' '|| round((SPACE_USED-SPACE_RECLAIMABLE)/SPACE_LIMIT*100)
                 ||' '|| round(SPACE_LIMIT/1024/1024)
                 ||' '|| round(SPACE_USED/1024/1024)
                 ||' '|| round(SPACE_RECLAIMABLE/1024/1024)
          from V\$RECOVERY_FILE_DEST, v\$database d;
         " >> $filename
}

do_spool_undostat()
{
    filename=${1}
    echo 'PROMPT <<<oracle_undostat>>>' >> $filename
    echo "select upper(i.INSTANCE_NAME)
                 ||' '|| ACTIVEBLKS
                 ||' '|| MAXCONCURRENCY
                 ||' '|| TUNED_UNDORETENTION
                 ||' '|| maxquerylen
                 ||' '|| NOSPACEERRCNT
          from v\$instance i,
              (select * from (select * 
                              from v\$undostat order by end_time desc
                             )
                        where rownum = 1
                        and TUNED_UNDORETENTION > 0
              );
         " >> $filename
}

do_spool_resumable()
{
    filename=${1}
    echo 'PROMPT <<<oracle_resumable>>>' >> $filename
    echo "select upper(i.INSTANCE_NAME)
                 ||' '|| u.username
                 ||' '|| a.SESSION_ID
                 ||' '|| a.status
                 ||' '|| a.TIMEOUT
                 ||' '|| round((sysdate-to_date(a.SUSPEND_TIME,'mm/dd/yy hh24:mi:ss'))*24*60*60)
                 ||' '|| a.ERROR_NUMBER
                 ||' '|| to_char(to_date(a.SUSPEND_TIME, 'mm/dd/yy hh24:mi:ss'),'mm/dd/yy_hh24:mi:ss')
                 ||' '|| a.RESUME_TIME
                 ||' '|| a.ERROR_MSG
          from dba_resumable a, v\$instance i, dba_users u
          where a.INSTANCE_ID = i.INSTANCE_NUMBER
          and u.user_id = a.user_id
          and a.SUSPEND_TIME is not null
;
         " >> $filename
}

do_spool_scheduler_jobs()
{
    filename=${1}
    resultfile=$2
    resultfiletmp=${resultfile}.tmp
    echo "spool "$resultfile >> $filename
    echo 'PROMPT <<<oracle_jobs>>>' >> $filename
    echo "SELECT upper(d.NAME)
                 ||' '|| j.OWNER
                 ||' '|| j.JOB_NAME
                 ||' '|| j.STATE
                 ||' '|| (TRUNC(sysdate) + j.LAST_RUN_DURATION - TRUNC(sysdate)) * 86400
                 ||' '|| j.RUN_COUNT
                 ||' '|| j.ENABLED
                 ||' '|| NVL(j.NEXT_RUN_DATE, to_date('1970-01-01', 'YYYY-mm-dd'))
                 ||' '|| NVL(j.SCHEDULE_NAME, '-')
                 ||' '|| d.STATUS
          FROM dba_scheduler_jobs j, dba_scheduler_job_run_details d, v\$database d
          WHERE d.owner=j.OWNER AND d.JOB_NAME=j.JOB_NAME
            AND d.LOG_ID=(SELECT max(LOG_ID) FROM dba_scheduler_job_run_details dd
                          WHERE dd.owner=j.OWNER and dd.JOB_NAME=j.JOB_NAME
                         );
         " >> $filename
    echo "!mv -f "$resultfiletmp" "$resultfile" ; date +%s > "${resultfile}.timestamp >> $filename
}


do_spool_ts_quotas()
{
    filename=${1}
    resultfile=$2
    resultfiletmp=${resultfile}.tmp
    echo "spool "$resultfiletmp >> $filename
    echo 'PROMPT <<<oracle_ts_quotas>>>' >> $filename
    echo "select upper(d.NAME)
                 ||' '|| USERNAME 
                 ||' '|| TABLESPACE_NAME
                 ||' '|| round(bytes/max_bytes*100)
                 ||' '|| BYTES/1024/1024
                 ||' '|| MAX_BYTES/1024/1024
          from dba_ts_quotas, v\$database d
          where max_bytes  > 0
          order by 1;
         " >> $filename
    echo "!mv -f "$resultfiletmp" "$resultfile" ; date +%s > "${resultfile}.timestamp >> $filename
}

create_result_for_check()
{
    loc_CHECK_NAME=$1
    loc_CACHE_MAXAGE=$2
    loc_MK_SQLRESULT=$3
    loc_MK_SQLTMPFILE=$4
    loc_DO_SPOOL_NAME=$5

    # current date in unixtime for later usage
    NOW=$(date +%s)
    if [ ! '$EXCLUDE' = '${EXCLUDE/todo/}' ]; then
        # do we have a cached file?
        if [ -f ${loc_MK_SQLRESULT}.timestamp ]; then
            # Is the cached file outdated?
            MTIME=$(cat ${loc_MK_SQLRESULT}.timestamp)
            if [ $(($NOW - $MTIME)) -gt $loc_CACHE_MAXAGE ]; then
                # create sql for $CHECK_NAME
                $loc_DO_SPOOL_NAME $loc_MK_SQLTMPFILE $loc_MK_SQLRESULT
            else
                # print cached data
                cat $loc_MK_SQLRESULT
            fi
        else
            # create sql for monitoring
            $loc_DO_SPOOL_NAME $loc_MK_SQLTMPFILE $loc_MK_SQLRESULT
        fi
    fi
}

do_version_checks()
{
        # oracle_instance: uptime is 0 when sysdate > startup_time in instance
        #                  this is required when time is changed on the host
        # sqlplus returns OUTPUT with the result of the check!
        sqlplus $SID <<_EOF_
           PROMPT <<<oracle_version>>>
           select upper(i.INSTANCE_NAME)
                  || ' ' || banner 
                  from v\$version, v\$instance i
                  where banner like 'Oracle%';

           prompt <<<oracle_instance>>>
           select upper(i.instance_name)
	          || ' ' || i.VERSION
	          || ' ' || i.STATUS
	          || ' ' || i.LOGINS
	          || ' ' || i.ARCHIVER
                  || ' ' || to_char(i.startup_time,'dd.mm.yyyy_hh24:mi:ss') 
                  || ' ' || DBID
                  || ' ' || LOG_MODE
                  || ' ' || DATABASE_ROLE
                  || ' ' || FORCE_LOGGING
                  || ' ' || case when ((sysdate-startup_time)<0) then 0 
                                 else (round(sysdate-startup_time)*24*60*60) end
	          || ' ' || d.name
           from v\$instance i, v\$database d;

           prompt <<<oracle_sessions>>>
           select upper(i.instance_name)
                  || ' ' || CURRENT_UTILIZATION
           from v\$resource_limit, v\$instance i
           where RESOURCE_NAME = 'sessions';

           prompt <<<oracle_processes>>>
           select upper(i.instance_name)
                  || ' ' || CURRENT_UTILIZATION
                  || ' ' || ltrim(rtrim(LIMIT_VALUE))
           from v\$resource_limit, v\$instance i
           where RESOURCE_NAME = 'processes';

           prompt <<<oracle_logswitches>>>
           select upper(i.instance_name)
                  || ' ' || logswitches
           from v\$instance i ,
                (select count(1) logswitches
                 from v\$loghist 
                 where first_time > sysdate - 1/24
                );
_EOF_
if [ ${?} -ne 0 ]
then
    # We need to print the sections when sqlplus results an error
    # => otherwise the Check_MK generates an error due to missiing sections
    echo "<<<oracle_version>>>"
    echo "<<<oracle_instance>>>"
    # We print the whole result to oracle_instance for debugging
    echo "${OUTPUT}"  | sed "s/^/$SID_UPPER FAILURE /" | grep "^"$SID_UPPER" FAILURE ORA-"

    echo "<<<oracle_sessions>>>"
    echo "<<<oracle_processes>>>"
    echo "<<<oracle_logswitches>>>"
    echo "<<<oracle_undostat>>>"
else
    #
    echo -e "$OUTPUT"
fi
}

  # #          #     #     #     ###  #     #          # #
  # #          ##   ##    # #     #   ##    #          # #
#######        # # # #   #   #    #   # #   #        #######
  # #          #  #  #  #     #   #   #  #  #          # #
#######        #     #  #######   #   #   # #        #######
  # #          #     #  #     #   #   #    ##          # #
  # #          #     #  #     #  ###  #     #          # #

clear_cache

for SID in $SIDS; do
    # We need the SID in uppercase at later time
    SID_UPPER=$(echo $SID | tr '[:lower:]' '[:upper:]')

    # Check if SID is listed in ONLY_SIDS if this is used
    if [ "$ONLY_SIDS" ] ; then
        SKIP=yes
        for S in $ONLY_SIDS ; do
	    if  [ "$S" = "$SID" ] ; then
                SKIP=
                break
            fi 
        done
        if [ "$SKIP" ] ; then continue ; fi
    fi
        
    EXCLUDE=EXCLUDE_$SID
    EXCLUDE=${!EXCLUDE}
    # SID filtered totally?
    if [ "$EXCLUDE" = "ALL" ]; then
        continue
    fi

    # MK_SQLTMPFILE is execute in sqlplus.sh at the end of the loop
    # we need an unique identifier for the sql-file
    MK_SQLTMPDIR=/tmp
    MK_SQLTMPFILE=$MK_SQLTMPDIR"/.mk_oracle_oracle_"$SID"_"$(date +%s)".sql"
    MK_SQLTMPFILENOW=$MK_SQLTMPDIR"/.mk_oracle_oracle_"$SID"_now_"$(date +%s)".sql"

    # store the result of sqlplus.sh for each check in 1 file
    # we won't execute every check while running the agent
    # => we add the chached data for each check to complete the result of the agent

    MK_SQLRESULT_TABLESPACE=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_tablespace.data"
    MK_SQLRESULT_RMAN_BACKUP=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_rman_backup.data"
    MK_SQLRESULT_JOBS=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_jobs.data"
    MK_SQLRESULT_TS_QUOTA=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_ts_quota.data"

    # This dummy is needed for checks in 
    MK_SQLRESULT_DUMMY=$MK_SQLTMPDIR"/.mk_oracle_"$SID"_dummy.data"

    # Do Version-Check (use as a general login check) without caching
    # get some interesting data from database and instance
    # these sqls are really fast. No need to cache these results!
    # These Checks are running from 9i onwards. No need for filtering atm
    if [ "$EXCLUDE" = "${EXCLUDE/version/}" ]; then
        do_version_checks
    fi

    ###########################################################
    #      synchron Checks
    ###########################################################
    # no caching on recovery area
    # => this v$-view has a low performance impact on the database
    # => This is only availible from 10g onwards
    create_result_for_check recovery_area 1 $MK_SQLRESULT_DUMMY ${MK_SQLTMPFILENOW}"_dummy" do_spool_recovery_area

    # 'spool' in sqlplus overwrites the spoolfile everytime a new file with same name is opened
    # add sql-statement from create_result_for_check to MK_SQLTMPFILENOW
    cat ${MK_SQLTMPFILENOW}"_dummy" > ${MK_SQLTMPFILENOW}
    rm -f ${MK_SQLTMPFILENOW}"_dummy"

# vorerst entfernt, weil es noch Probleme mit Instancen im MOUNT-Status gibt!
#    create_result_for_check resumable 1 $MK_SQLRESULT_DUMMY ${MK_SQLTMPFILENOW}"_dummy" do_spool_resumable
#    cat ${MK_SQLTMPFILENOW}"_dummy" >> ${MK_SQLTMPFILENOW}
#    rm -f ${MK_SQLTMPFILENOW}"_dummy"

    create_result_for_check undostat 1 $MK_SQLRESULT_DUMMY ${MK_SQLTMPFILENOW}"_dummy" do_spool_undostat
    cat ${MK_SQLTMPFILENOW}"_dummy" >> ${MK_SQLTMPFILENOW}
    rm -f ${MK_SQLTMPFILENOW}"_dummy"


    # only try to execute sqlplus when data must be read from database
    # this is the synchronous call!
    if [ -f $MK_SQLTMPFILENOW ]
    then
        sqlplus $SID <<_EOF_
@$MK_SQLTMPFILENOW
_EOF_
    sqlplussyncheck=${?}
    if [ ${sqlplussyncheck:-1} -ne 0 ]
    then
        # We need to print the sections when sqlplus results an error
        # => otherwise the Check_MK generates an error due to missiing sections
        echo "<<<oracle_undostat>>>"
    else
        #
        echo -e "$OUTPUT"
    fi




    fi

    # don't execute asynchronous Checks when synchronous checks are failed
    # => prevent nasty errors from asynchronous checks due to offline instance
    if [ ${sqlplussyncheck:-1} -ne 0 ]
    then
        echo '<<<oracle_tablespaces>>>'
        echo '<<<oracle_ts_quotas>>>'
        echo '<<<oracle_resumable>>>'
        echo '<<<oracle_jobs>>>'
        echo '<<<oracle_rman_backups>>>'
    else
        ###########################################################
        #      asynchron Checks
        ###########################################################
        create_result_for_check tablespaces $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_TABLESPACE $MK_SQLTMPFILE do_spool_tablespace
        create_result_for_check ts_quotas $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_TS_QUOTA $MK_SQLTMPFILE do_spool_ts_quotas
        create_result_for_check rman_backup $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_RMAN_BACKUP $MK_SQLTMPFILE do_spool_rman_backup
        create_result_for_check jobs $CACHE_MAXAGE_TABLESPACE $MK_SQLRESULT_JOBS $MK_SQLTMPFILE do_spool_scheduler_jobs

        echo '<<<oracle_tablespaces>>>'
        echo '<<<oracle_ts_quotas>>>'
        echo '<<<oracle_resumable>>>'
        echo '<<<oracle_jobs>>>'
        echo '<<<oracle_rman_backups>>>'

        # only try to execute sqlplus when data must be read from database
        # this is the asynchronous call!
        if [ -f $MK_SQLTMPFILE ]
        then
            test -d /tmp/.mk_oracle || mkdir /tmp/.mk_oracle
            cd /tmp/.mk_oracle
            nohup bash -c "
                set -o noclobber
                function sqlplus ()
                {
                    if OUTPUT=\$({ echo 'set pages 0 trimspool on' ; echo 'whenever OSERROR  EXIT ROLLBACK' ; echo 'whenever sqlerror exit 1'; echo 'set lines 8000' ; echo 'set feedback off'; cat ; } | $MK_CONFDIR/sqlplus.sh \$1)
                   then
                       export OUTPUT
                       return 0
                       #echo \"\${OUTPUT}\"
                   else
                       OUTPUT=\$\{OUTPUT\} | sed \"s/^/\$2 FAILURE /\"
                       export OUTPUT
                       return 1
                       echo \"\$\{OUTPUT\}\" | sed \"s/^/\$2 FAILURE /\"
                    fi
                }
            sqlplus "$SID" "$SID_UPPER" <<_EOF_
@$MK_SQLTMPFILE
_EOF_
            if [ \${?} -ne 0 ]
            then
                # We need to print the sections when sqlplus results an error
                # => otherwise the Check_MK generates an error due to missiing sections
                echo '<<<oracle_tablespaces>>>'
                echo '<<<oracle_ts_quotas>>>'
                echo '<<<oracle_resumable>>>'
                echo '<<<oracle_jobs>>>'
                echo '<<<oracle_rman_backups>>>'
            else
                #
                echo -e \"\$OUTPUT\"
            fi
            rm -f $MK_SQLTMPFILE 
            &"  > /dev/null 2>&1 
        fi
    fi

    rm -f $MK_SQLTMPFILENOW

done

